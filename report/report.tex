\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[bitstream-charter]{mathdesign}
\usepackage[T1]{fontenc}
\usepackage[scaled]{beramono}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{parskip}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{xcolor}
\definecolor{dkgreen}{rgb}{0,0.6,0}

\lstset{
  aboveskip=3mm,%
  basewidth={0.58em, 0.53em},%
  basicstyle=\renewcommand{\baselinestretch}{0.95}\ttfamily,%
  belowskip=3mm,%
  breakatwhitespace=true,%
  breaklines=true,%
  captionpos=b,%
  columns=[c]fixed,%
  commentstyle=\itshape\color{dkgreen},%
  escapechar=¤,%
  firstnumber=0,%
  fontadjust=true,%
  framerule=0.3pt,%
  keepspaces=true,%
  frame=single,%
  keywordstyle=\bfseries\color{RoyalBlue},%
  language=Scala,%
  mathescape=true,%
  numbers=none,%
  numbersep=1.5mm,%
  numberstyle=\color{Magenta},%
  showstringspaces=false,%
  stringstyle=\color{Thistle},
  tabsize=2,%
  xleftmargin=4mm%
}
\newcommand{\code}[1]{%
    \lstinline[%keywordstyle=,%
               flexiblecolumns=true,%
               basicstyle=\ttfamily]#1}

% Put code in \cc{THE_CODE}, \cc{...} is shorter than \texttt{...}
\newcommand{\cc}[1]{\texttt{#1}}
% Put Scala code in \sc{THE_CODE}, the code will be syntax highlighted
% Use \cc{..} for class names
\renewcommand{\sc}[1]{\lstinline{#1}}
\newcommand{\field}[1]{\emph{#1}}
\begin{document}
\selectlanguage{english}

\title{Comparative Programming Languages\\
Assignment $^{\#}$2: Domain Specific Language}
\author{Glenn Croes \and Philippe De Croock \and Thomas Winant}
\date{11 January, 2012}

\maketitle

\tableofcontents

\section{Domain description}
\label{sec:domain-description}

% An elaboration on elements of the domain that were missing or needed to be improved, plus justification for any choices made.


% Vluchtnummer per vlucht, onafhankelijk van het vliegtuig
% Schedule-schedulItem kan mss nog worden verbeterd
% tijdstip per flight
% elke 1..* ipv 0..* in ons systeem
% Each flight of a certain flight template happens with the same airplane model

This section will reflect on the most important aspects of the problem domain.
We will not discuss the entirety of the problem domain or everything described in the assignment.
Only the important/changed parts are highlighted.

\begin{itemize}

\item It is necessary to support flexible modeling of flight schedules AND pricing (exceptions for holidays, variations in pricing etc.).
It must be possible to express statements such as ``The flight occurs every wednesday and friday at 16:30PM except from July to August'' and ``In December and January the prices are increased by 20\%''.
We do assume flights have a recurring period of just one week (every wednesday, every monday,\dots).
The question if longer types of recurring schedules had to be supported (every two weeks, monthly,\dots) was posed to the domain expert, but no answer was given.
The assignment only describes weekly schedules:

\begin{quote}
Each code denotes a flight that recurs at the same time one or more days per week.
(Some flight takes place on just one day per week, others a couple of days per week, others every day.)
\end{quote}

So, for simplicity,  we decided to stick with just weekly recurring schedules.
Note: it is still possible to express variations and exceptions (e.g. every wednesday except in January or every monday except on December 25th)! \\

\item Each seat is assigned to a price category (\field{SeatType}).
Seats are priced individually, but prices fall into one of these categories.
Price categories are determined in advance.
However, a seat may change price category during a certain period (e.g. during high season).

\item The same flight can be serviced by multiple airplanes (even different airplane models).
We decided to treat \field{Airplane}s, \field{AirplaneModel}s and airplane \field{Manufacturer}s as seperate entities.\\

\item Code-sharing flights (multiple companies for one flight) can be ignored as stated by the domain expert.\\

\item As hinted in the assignment, we decided to introduce the concept of a \field{FlightTemplate}.
For a description, see ~\ref{par: flighttemplate}. \\

\item Flight details are available one year in advance. It is not necessary to generate flight data for an unlimited period of time (as stated by the domain expert).\\

\item Only the insertion of data into the database needs to be supported by the DSL.
Booking of flights and querying data is not part of our problem domain.
We also assume every entity is described in the DSL file.
No pre-existing entities are refered to.
For example: it is not possible to refer to a country ``Australia'' if that country is not declared in the DSL file (but exists in the database).
We will not check everything that is already in the database before interpreting the DSL file.\\

\item The assignment states it should be possible to provide flight duration estimates.
We decided not to explicitly describe flight durations in \field{Flight}, but to keep track of the airplane's average cruise speed in order to be able derive the flight duration.
We assume the cruising speed is the most prominent factor that determines flight duration.
This should provide a better estimate of the flight's duration, as a flight may be serviced by different airplane models.\\


\end{itemize}

\section{Domain analysis}
\label{sec:domain-analysis}
% A brief breakdown of the elements in your domain and how they relate to each other. This could be a formal meta-model, but could also be textual description.

\begin{figure}[ht!]
  \includegraphics[width=1.0\textwidth]{../analysis/domainModel.pdf}
  \caption{Domain Model}\label{fig:domain-model}
\end{figure}

\paragraph{Country}
A \field{Country} has a name and represents a sovereign nation.
\paragraph{City}
A \field{City} has a name and is located in a \field{Country}.
\paragraph{Airport}
An \field{Airport} is located in a \field{City}.
It has a name and is uniquely identified by its 3 capital letter code.
It is possible for a city to have multiple airports.
\paragraph{Connection}
A \field{Connection} represents a flight link between two airports.
The distance in kilometers of the connection is stored.
A connection must be between two different airports.
\paragraph{AirlineCompany}
An \field{AirlineCompany} provides air transport services for passengers.
It has a name and is uniquely identified by a 2 or 3 capital letter code.
\paragraph{Manufacturer}
A \field{Manufacturer} is a business engaged in manufacturing airplanes.
Only the name of the manufacturer is relevant in our domain.
\paragraph{AirplaneModel}
An \field{AirplaneModel} is manufactured by a manufacturer.
It has a name and cruise speed.
The maximum number of seats that can be installed in the airplane model is stored too.
\paragraph{FlightTemplate}\label{par: flighttemplate}
A \field{FlightTemplate} describes a set of \field{Flight}s on the same \field{Connection}, serviced by a certain \field{AirlineCompany} with a certain schedule.
Each \field{FlightTemplate} is denoted by a unique code.
The code consists of the airline company's code followed by 3 to 4 digits.
An example: The \field{FlightTemplate} describing all flights between Amsterdam and Sydney serviced by KLM. This \field{FlightTemplate} has the code KLM4119.
The flights occur every wednesday at 12:00PM, except from the 20th of December until the 5th of January. 

% TODO
% recurs at the same time one or more
% days per week
% flight that recurs at the same time one or more
% days per week. (Some flight takes place on just one day per week, others a
% couple of days per week, others every day.)
% To specify a specific flight, the date is also required.

% It is probably a good idea to separate the information about the flight and the
% ‘template’ describing flights. The ‘template’ includes the flight code, but the
% actual flight details include the date.

\paragraph{Flight}
A \field{Flight} is an instantiation of a flight template at a particular date and time.
As they are dependent on a flight template, flights are specific to airline companies.
A flight will happen with a certain airplane model.
\paragraph{SeatType}
A \field{SeatType} is used to define seat classes, for instance business and economy are two seat types.
Only the name of the seat type is stored.
Different airline companies can reuse the same seat types.
\paragraph{Seat}
A \field{Seat} represents a seat on a flight.
A seat has a seat number that is unique on the airplane.
\paragraph{Price}
Every seat on a flight has a \field{Price}.
The price depends on the flight and the seat type.
This means that two seats, both of the same seat type and both on flights that follow the same template, can have different prices on different dates.



\begin{figure}[ht!]
  \includegraphics[width=1.0\textwidth]{../analysis/dbtables-diagram.png}
  \caption{Database Tables}\label{fig:database-tables}
\end{figure}

\section{Design \& Implementation}
\label{sec:implementation-overview}

% A description of the semantic model underlying the DSL, along with a description of the constructs of your DSL.

% A general overview of the implementation approach, including a description of the API upon which it is based and any tricky implementation techniques employed. Some justification of the chosen implementation language needs also to be provided.

TODO API

\subsection{Implementation language}
\label{sec:implementation-language}

We chose to implement our DSL in Scala for the following reasons:

\paragraph{Static Typing}
Scala is statically typed and has a rather advanced type system.
Scala's type system allows us to express and verify more complex types of expressions.
A whole class of consistency checks related to types can be eliminated in the DSL, thanks to static typing.

\paragraph{Familiarity}
Although only one group member had experience with programming in Scala before the \textsc{CPL} course, Scala is not too unfamiliar for experienced Java programmers.
Syntactically, Scala is quite similar to Java.
Programmers familiar with the object-oriented paradigm as it is applied in Java, can start programming in Scala relatively easy, as the \textsc{OO} paradigm is also present in Scala, albeit enhanced and combined with the functional programming paradigm.

\paragraph{Feature Set}
Scala provides programmers with many useful building blocks for developing DSLs, including, but not limited to:

\begin{itemize}
\item \textbf{Implicits arguments and conversions}:
  Implicit arguments alleviate the need to pass around certain parameters, making the program less verbose and more intuitive to read (at times).
  Implicit conversions provide an easy way to add functionality to existing classes, we used it mainly to add syntactic sugar (see Section~\ref{sec:implementation-syntax}).
\item \textbf{Operator syntax}:
  Scala supports the definition of operators just like methods, e.g.\ \sc{BRU -> CDG} is actually a method call.
  The dot and parentheses in a functional call can be omitted in certain circumstances, allowing more natural language-like syntax, e.g.\ \sc{"Brussels" in Belgium}.
\item \textbf{Traits}:
  Traits are (also) a useful way to structure to code into units of functionality.
  Instead of being forced to stick to a strict inheritance relation, or to put all code in one place, we can compartmentalize the functionality into different traits.
\end{itemize}

\paragraph{Scala 2.9 vs 2.10}

We used Scala version 2.9.2 to implement our DSL.
Although version 2.10, which includes many useful enhancements, was recently released, it (or at least a final version) wasn't available at the start of the assignment.
Scala 2.10 has (experimental) support for macros, a very powerful and much wished-for tool for DSL designers.
Implicit classes are also available in 2.10, which reduce the boilerplate required for some of the tricks described in Section~\ref{sec:implementation-syntax}.
Another useful addition is the \cc{Dynamic} type: ``\sc{x.foo} becomes \sc{x.applyDynamic("foo")} if \sc{x}'s type does not define a \sc{foo}, but is a subtype of \cc{Dynamic}''.
This trick, the equivalent of Ruby's \cc{method\_missing}, would be very useful to support extra syntax.
In hindsight, our DSL could have been much \emph{prettier} if we used Scala 2.10, but because the final version was released only recently (January 4th) and because of time constraints, we chose to stick to the latest stable release, 2.9.2.

\subsection{Design Description}
\label{sec:design-description}


Before a high-level walk through the implementation, we shall first describe the design behind our DSL.
The idea is to define Cities, Airports, Flights, \ldots{} using an easy to use and intuitive syntax.
All defined \emph{entities} will then be stored in a database.
Flight entities are generated from FlightTemplates using a \cc{Schedule} and a \cc{Pricing\-Scheme} (more about these later).
The database is populated after all entities are defined and the required consistency checks are performed.
Communication with the database happens through \textsc{JDBC} (Java Database Connectivity).
As we're using \textsc{JDBC}, we could support a whole host of different database types.
Currently, we support SQLite (no extra setup required, as the database is stored in a file), which is also the default, and MySQL (one of the most popular database products).
After running our DSL program, the database will contain the rows defined using the DSL.\@
% TODO import tables?

We first intended to generate SQL scripts that would insert the generated entities in the database when executed, but this proved to be difficult because of the following reason.
Imagine we want to generate an \cc{INSERT} statement that would insert a new City in the database.
A City consists of a name of type String, and a country of type Country, which is another entity (or table).
In the database table, the country field of the City table is defined as a foreign key that references the Country table via Country's primary key (an auto-generated ID).
How would such an \cc{INSERT} statement then look like?

\cc{INSERT INTO City (name, id\_Country) VALUES ("Brussels", ?)}

Which value should come in the place of the question mark?

The right thing to do, would be to insert the value of the auto-generated ID of the row representing Belgium in the Country table, but we don't know the value of this ID, as we haven't inserted Belgium it in the database yet.
A possible alternative is to switch to manually generated IDs, but extra attention would have to be paid to prevent conflicts with existing IDs.
We believe directly communicating with the database at run-time and retrieving the IDs after they were generated, is a more robust solution.

\subsection{General Implementation Overview}
\label{sec:general-implementation-overview}

Now follows a high-level tour of the most important parts of our DSL implementation.
The name of the source file is mentioned in bold.
More details can be learned from reading the source files, which are provided with commentary.

\paragraph{DBDefinition.scala}
First of all, we defined case classes for every table or \cc{Entity} in the database.
The fields of a table correspond with the fields of the case classes, except for the auto-generated keys.
Custom fields, like \cc{Airport\-Code} and \cc{Air\-line\-Code}, were defined as well.

\paragraph{DBDSL.scala}
We used a tiny DSL to define these entities (tables).
This DSL contains the \cc{Entity} trait, that all tables extend.
An Entity can insert itself into a database using a \cc{PreparedStatement}.

\paragraph{DateAndTime.scala}
We defined a number of auxiliary classes (\cc{WeekDay}, \cc{Month}, \cc{Date}, \cc{Time}, and \cc{DateTime}) for working with dates and times.
These classes are mostly wrappers for existing classes from the \href{http://joda-time.sourceforge.net/}{Joda-time library} that provide extra syntactic sugar and methods.
We chose not to implement the extra functionality in the form of implicit conversions, as the users of our DSL are already working with custom syntax and don't come in touch with the underlying types.

\paragraph{SQLPopulator.scala}
To support multiple types of databases (currently SQLite and MySQL), we abstracted the common functionality of databases in a trait, \cc{SQL\-Populator}.
Adding support for a new type of database requires the definition of a new trait that implements the abstract members of SQLPopulator.
The only abstract member of this trait is:

\sc{def connect(jdbcString: String): Connection}

This method will be called only once, should load the correct JDBC driver, and return a new connection to the database.
Also present is the \cc{SQLDataTypeMapper} trait, which takes care of filling in a PreparedStatement with the appropriate methods, e.g.\ \cc{Prepared\-State\-ment\-\#set\-String(..)}, \cc{Prepared\-State\-ment\-\#set\-Int(..)}, etc.
The default methods in this trait can also be overriden by database-specific ones, as for example SQLite does not support the \cc{Prepared\-State\-ment\-\#set\-Big\-Decimal(..)} method.
The user of our DSL can choose which database to use by mixing-in the database-specific SQLPopulator trait (\cc{SQLitePopulator} or \cc{MySQL\-Populator}) of his choice.

\paragraph{FlightDSL.scala}
The actual DSL that will be used by users is defined in \cc{Flight\-DSL.scala}.
The DSL provides lot of syntactic sugar for defining the Countries, Cities, Airports, Manufacturers (of airplanes), Airplane Models, Airline Companies, Seat Types, and Flight Templates.
All entities of a certain type defined by the user using DSL syntax are also stored in a Vector.
At the end, all Vectors are stored in the database.

In our DSL, the user defines Flight Templates from which Flights are generated.
A Flight is an instantiation of a Flight Template at a certain date and time.
To generate Flights at certain points in time, a Schedule is used.
A Schedule is defined through composition.
Have a look at the following example:
% \code{var x = 3 + 1}
\begin{lstlisting}
val wholeYear = (1 January 2012) -> (31 December 2012)
new Schedule()
 .at(9 h 55, every(Monday) during wholeYear) {
  Business -> (25.seats at 250.EUR);
  Economy -> (110.seats at 150.EUR)
}.except(25 December 2012, 6 January 2013)
 .at(15 h 3, 24 December 2012) {
  Business -> (20.seats at 400.EUR);
  Economy -> (125.seats at 300.EUR)
}
\end{lstlisting}

The first line in the example defines an interval between the beginning of 2012 and the end of 2012, i.e.\ the year 2012.
The Schedule that is defined states that every Monday of the year, a flight at five to ten in the morning with 25 business seats for 250 euros and 110 economy seats for 150 euros is planned, except on Christmas (if Christmas happened to fall on a Monday in 2012).
An additional flight is added that flies on the 24th of December, but with higher prices.

A Schedule object stores a sequence of moments when flights would occur, along with pricing information per seat class.
Flight objects will be generated for every moment in the Schedule.


To give maximum control over pricing information, we also introduced Pricing Schemes, which are Airline Company-specific.
A Pricing Scheme consists of a partial function from Seat Type, Date, and Price to Price.
It provides users an easy way to adjust prices on flights on certain dates and per Seat Type.
Have a look at the following example:

\begin{lstlisting}
new PricingScheme {
  def inSummer(date: Date): Boolean =
    date.in(21 June 2013, 21 September 2013)

  val highSeason: PricingScheme = {
    case (_, date, price) if inSummer(date) => price * 1.1
  }

  val firstClassTax: PricingScheme = {
    case (FirstClass, _, price) if price > 500.EUR
      => price + 50.EUR
  }

  val scheme = highSeason andAlso firstClassTax
}
\end{lstlisting}

A helper method is defined, \sc{inSummer}.
Two partial functions are defined and composed to form the \sc{scheme}, the abstract partial function member that must be implemented.
The first partial function, \sc{highSeason}, raises the price of flights in the summer by 10\%.
The second partial function, \sc{firstClassTax}, raises the price of first class flights by 50 euros if the price of the flight exceeds 500 euros.

We believe Pricing Schemes give users enough control over flight pricing.
Of course, additional input parameters could be added, like the Airplane Model or the time of departure, but such changes require only little work.
Users that wish not to use Pricing Schemes can provide a simple fall-through Pricing Scheme that doesn't influence the price at all.

\subsection{Syntax}
\label{sec:implementation-syntax}

A pattern (or trick) we often used to add some syntactic sugar is the following.
Suppose we want to define a city, Brussels for instance, in our DSL.\@
\cc{City} is a case class with the following definition:

\sc{case class City(name: String, country: Country)}\ldots{}

Instead of \sc{val Brussels = City("Brussels", Belgium)} (\cc{Belgium} is an existing value of type \cc{Country}), we would like to define the city in a style resembling natural language.\\
For example: \sc{val Brussels = "Brussels" in Belgium}.\footnote{It's a shame we have to mention ``Brussels'' twice.}
The \sc{in} in the example above is actually a method call on the string \cc{Brussels} with \cc{Belgium} as sole argument.
Of course, there is no \sc{in} method taking a \cc{Country} defined for strings.
Using implicit conversions we can easily implement it:

\begin{lstlisting}
implicit def cityIn(cityName: String) = new {
  def in(country: Country) = City(cityName, country)
}
\end{lstlisting}

The code above defines an implicit conversion from a string (\sc{cityName}) to a new object on which the method \sc{in(country: Country)} is defined which returns a newly constructed \cc{City} object.

We also applied this pattern to provide a pretty syntax to define dates, e.g.\ \sc{val christmas = 25 December 2013}.
\cc{December} is actually a method defined on \cc{Int} (the day of the month) that takes a year argument.

This pattern can be applied recursively to form a sentence where method calls connect arguments together.\\
E.g.\ \sc{"Airbus A320" of Airbus carries 150.p flies 828.kmh}\\
The required implicit conversion:

\begin{lstlisting}
implicit def airplaneModelOf(modelName: String) =  new {
  def of(company: Manufacturer) = new {
    def carries(passengers: Passengers) = new {
      def flies(speed: Kmh): AirplaneModel =
        AirplaneModel(modelName, passengers.ps,
                      speed.kmhs, company)
    }
  }
}
\end{lstlisting}

As you can see in the example above, some numbers have a suffix to make their meaning clearer.
For example, the \sc{.kmh} in \sc{flies 828.kmh} immediately makes clear that the number is actually the speed, expressed in km/h.
Without the suffix, it could mean anything, e.g.\ ``flies 828 around the world before requiring maintenance''.
This is another trick we often applied to improve the legibility of our DSL.
The suffix is actually a method defined on \cc{Int} via an implicit conversion.
The implicit conversion that facilitates this:
\begin{lstlisting}
case class Kmh(kmhs: Int)

implicit def kmhUnit(kmhs: Int) = new {
  def kmh: Kmh = Kmh(kmhs)
}
\end{lstlisting}

By defining separate case classes for these unit types instead of relying on the built-in types like \cc{Int} or \cc{Double}, the type checker will signal a type error whenever a user of our DSL forgets a suffix that converts a number to the right unit type.
Of course, we could make it more extensible by defining a trait for speed, which \cc{KmH} and other classes like \cc{MpH} could implement, but this is a small change that could easily be made when necessary.



\section{DSL Implementation}
\label{sec:dsl-implementation}

% The code implementing your DSL and any libraries on which it is based.

\section{Example DSL program(s)}
\label{sec:example-dsl-programs}

% Some example DSL programs to illustrate how your DSL is to be used.

\section{DSL Cheat sheet}
\label{sec: cheat-sheet}

\input{cheatsheet}

\section{Guide}
\label{sec:guide}

% to use A short description of how to compile and run your DSL and a guide to the structure of the submitted files.



\end{document}


%%% Local Variables:
%%% mode: latex
%%% ispell-local-dictionary: american
%%% TeX-master: t
%%% End:
